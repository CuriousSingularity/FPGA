-- -------------------------------------------------------------
-- 
-- File Name: Streaming_VHDL\fil_videosharp_sim\Make_Neighborhood.vhd
-- Created: 2019-06-18 09:45:08
-- 
-- Generated by MATLAB 9.6 and HDL Coder 3.14
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: Make_Neighborhood
-- Source Path: fil_videosharp_sim/Streaming 2-D FIR Filter/Make Neighborhood/Make Neighborhood
-- Hierarchy Level: 2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.Streaming_2_D_FIR_Filter_pkg.ALL;

ENTITY Make_Neighborhood IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        columnIn                          :   IN    vector_of_std_logic_vector8(0 TO 2);  -- uint8 [3]
        colIndex                          :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
        rowIndex                          :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
        frameSize                         :   IN    vector_of_std_logic_vector16(0 TO 1);  -- uint16 [2]
        activePixel                       :   IN    std_logic;
        y                                 :   OUT   vector_of_std_logic_vector8(0 TO 8)  -- uint8 [9]
        );
END Make_Neighborhood;


ARCHITECTURE rtl OF Make_Neighborhood IS

  -- Functions
  -- HDLCODER_TO_STDLOGIC 
  FUNCTION hdlcoder_to_stdlogic(arg: boolean) RETURN std_logic IS
  BEGIN
    IF arg THEN
      RETURN '1';
    ELSE
      RETURN '0';
    END IF;
  END FUNCTION;


  -- Signals
  SIGNAL columnIn_unsigned                : vector_of_unsigned8(0 TO 2);  -- uint8 [3]
  SIGNAL colIndex_unsigned                : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL rowIndex_unsigned                : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL frameSize_unsigned               : vector_of_unsigned16(0 TO 1);  -- uint16 [2]
  SIGNAL y_tmp                            : vector_of_unsigned8(0 TO 8);  -- uint8 [9]
  SIGNAL old_cols                         : vector_of_unsigned8(0 TO 5);  -- ufix8 [6]
  SIGNAL count_after_last_col             : std_logic;  -- ufix1
  SIGNAL row_index_reg                    : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL old_cols_next                    : vector_of_unsigned8(0 TO 5);  -- ufix8 [6]
  SIGNAL count_after_last_col_next        : std_logic;  -- ufix1
  SIGNAL row_index_reg_next               : unsigned(8 DOWNTO 0);  -- ufix9

BEGIN
  outputgen2: FOR k IN 0 TO 2 GENERATE
    columnIn_unsigned(k) <= unsigned(columnIn(k));
  END GENERATE;

  colIndex_unsigned <= unsigned(colIndex);

  rowIndex_unsigned <= unsigned(rowIndex);

  outputgen1: FOR k IN 0 TO 1 GENERATE
    frameSize_unsigned(k) <= unsigned(frameSize(k));
  END GENERATE;

  Make_Neighborhood_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      old_cols <= (OTHERS => to_unsigned(16#00#, 8));
      count_after_last_col <= '0';
      row_index_reg <= to_unsigned(16#000#, 9);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        old_cols <= old_cols_next;
        count_after_last_col <= count_after_last_col_next;
        row_index_reg <= row_index_reg_next;
      END IF;
    END IF;
  END PROCESS Make_Neighborhood_1_process;

  Make_Neighborhood_1_output : PROCESS (activePixel, colIndex_unsigned, columnIn_unsigned, count_after_last_col,
       frameSize_unsigned, old_cols, rowIndex_unsigned, row_index_reg)
    VARIABLE nhood : vector_of_unsigned8(0 TO 8);
    VARIABLE col_padded_nhood : vector_of_unsigned8(0 TO 8);
    VARIABLE row_padded_nhood : vector_of_unsigned8(0 TO 8);
    VARIABLE front_col_index : unsigned(7 DOWNTO 0);
    VARIABLE tail_col_index : unsigned(7 DOWNTO 0);
    VARIABLE front_row_index : unsigned(15 DOWNTO 0);
    VARIABLE start_row_tail_pad : unsigned(15 DOWNTO 0);
    VARIABLE stop_row_tail_pad : unsigned(15 DOWNTO 0);
    VARIABLE tail_row_index : signed(15 DOWNTO 0);
    VARIABLE sub_cast : signed(8 DOWNTO 0);
    VARIABLE sub_temp : signed(8 DOWNTO 0);
    VARIABLE sub_cast_0 : signed(31 DOWNTO 0);
    VARIABLE sub_temp_0 : signed(31 DOWNTO 0);
    VARIABLE cast : vector_of_signed32(0 TO 2);
    VARIABLE cast_0 : vector_of_signed32(0 TO 2);
    VARIABLE sub_cast_1 : vector_of_signed32(0 TO 2);
    VARIABLE sub_cast_2 : signed(16 DOWNTO 0);
    VARIABLE sub_temp_1 : signed(16 DOWNTO 0);
    VARIABLE sub_cast_3 : signed(16 DOWNTO 0);
    VARIABLE sub_temp_2 : signed(16 DOWNTO 0);
    VARIABLE sub_cast_4 : signed(16 DOWNTO 0);
    VARIABLE sub_temp_3 : signed(16 DOWNTO 0);
    VARIABLE sub_cast_5 : signed(15 DOWNTO 0);
    VARIABLE sub_cast_6 : signed(16 DOWNTO 0);
    VARIABLE sub_cast_7 : signed(15 DOWNTO 0);
    VARIABLE sub_temp_4 : signed(16 DOWNTO 0);
    VARIABLE add_cast : signed(15 DOWNTO 0);
    VARIABLE add_cast_0 : signed(16 DOWNTO 0);
    VARIABLE add_temp : signed(16 DOWNTO 0);
    VARIABLE cast_1 : vector_of_signed32(0 TO 2);
    VARIABLE cast_2 : vector_of_signed32(0 TO 2);
    VARIABLE cast_3 : vector_of_signed32(0 TO 2);
    VARIABLE cast_4 : vector_of_signed32(0 TO 2);
    VARIABLE cast_5 : vector_of_signed32(0 TO 2);
    VARIABLE add_cast_1 : vector_of_signed32(0 TO 2);
    VARIABLE cast_6 : signed(31 DOWNTO 0);
    VARIABLE sub_cast_8 : signed(16 DOWNTO 0);
    VARIABLE sub_temp_5 : signed(16 DOWNTO 0);
    VARIABLE cast_7 : unsigned(15 DOWNTO 0);
    VARIABLE cast_8 : signed(31 DOWNTO 0);
    VARIABLE add_cast_2 : signed(31 DOWNTO 0);
    VARIABLE add_temp_0 : signed(31 DOWNTO 0);
    VARIABLE cast_9 : unsigned(7 DOWNTO 0);
  BEGIN
    count_after_last_col_next <= count_after_last_col;
    row_index_reg_next <= row_index_reg;
    --------------------- Algorithm description ---------------------
    -- 1. initialization 
    --   1.1 shift registers  (for storing old data samples)
    --   1.2 initial assignment for proper eML datatype  
    --
    -- 2. column padding
    --   2.1 counter declaration (count after last column)
    --   2.2 boundary variables for column padding
    --       2.2.1 head padding variables 
    --       2.2.2 tail padding variables
    --   2.3 padding action 
    --
    -- 3. row padding 
    --   3.1 declaration - row index register 
    --   3.2 boundary variables for row padding
    --       3.2.1 head padding variables 
    --       3.2.2 tail padding variables
    --   3.3 padding action
    --
    -- 4. assign output 
    --
    -- 5. updating persistent variables
    --   5.1 shift registers (for storing old data_in)
    --   5.2 row index register 
    --   5.3 count after last column 
    -------------------------------------------------------------------
    -- ----------------------------------------------------------------
    --                    1. initialization 
    -- ----------------------------------------------------------------
    -- ###  1.1 Shift registers  (for storing old data samples) ###
    -- ###  1.2 initial assignment for proper eML datatype ###

    FOR t_1 IN 0 TO 1 LOOP
      FOR t_0 IN 0 TO 2 LOOP
        nhood(t_0 + (3 * t_1)) := old_cols(t_0 + (3 * t_1));
      END LOOP;
    END LOOP;

    nhood(6 TO 8) := columnIn_unsigned(0 TO 2);
    -- -----------------end  initialization ---------------------------
    -- ----------------------------------------------------------------
    -- ----------------------------------------------------------------
    --                    2. column padding 
    -- ----------------------------------------------------------------
    -- ###  2.1 counter declaration ( count after last column)  ###
    -- We need a counter to  tell us how many clock cycles 
    -- has passed after we received a last column i.e. How deep 
    -- is the last column in the pipeline
    -- ###   2.2 boundry variables for column Padding ###
    -- ###   2.2.1 head padding variables ###
    --start columns head padding 
    --when last column count is >= this 
    -- stop columns head padding 
    -- when last column count > this
    -- matrix indexes that needs to be padded
    sub_cast := signed(resize(colIndex_unsigned, 9));
    sub_temp := to_signed(16#003#, 9) - sub_cast;
    IF sub_temp(8) = '1' THEN 
      front_col_index := "00000000";
    ELSE 
      front_col_index := unsigned(sub_temp(7 DOWNTO 0));
    END IF;
    --col_head_pad_from = 1; 
    -- ###  2.2.2 tail padding variables ### 
    -- start columns tail padding 
    -- when count_after_last_col is >=this 
    -- stop columns tail padding 
    -- when count_after_last_col is > this 
    -- matrix indexes that needs to be padded
    sub_cast_0 := '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & count_after_last_col;
    sub_temp_0 := 3 - sub_cast_0;
    tail_col_index := unsigned(sub_temp_0(7 DOWNTO 0));
    --col_tail_pad_until = NH_COLS;
    -- ###   2.3 padding action ###

    FOR i IN 0 TO 2 LOOP
      cast(i) := signed(resize(front_col_index, 32));
      IF ((to_signed(1 + i, 32) < cast(i)) AND (colIndex_unsigned >= to_unsigned(16#00000001#, 8))) AND (colIndex_unsigned <= to_unsigned(16#00000002#, 8)) THEN 
        -- replicate padding

        FOR t_3 IN 0 TO 2 LOOP
          sub_cast_1(t_3) := signed(resize(front_col_index, 32));
          col_padded_nhood(t_3 + (3 * i)) := nhood(to_integer(to_signed(t_3, 32) + resize(3 * (sub_cast_1(t_3) - 1), 32)));
        END LOOP;

      ELSE 
        cast_0(i) := signed(resize(tail_col_index, 32));
        IF (to_signed(1 + i, 32) > cast_0(i)) AND (count_after_last_col >= '1') THEN 
          -- replicate padding
          col_padded_nhood(6 TO 8) := nhood(3 TO 5);
        ELSE 

          FOR t_2 IN 0 TO 2 LOOP
            col_padded_nhood(t_2 + (3 * i)) := nhood(t_2 + (3 * i));
          END LOOP;

        END IF;
      END IF;
    END LOOP;

    -- ----------------- end  column padding  -----------------------
    -- --------------------------------------------------------------
    -- ----------------------------------------------------------------
    --                    3. Row padding 
    -- ----------------------------------------------------------------
    -- ###   3.1 declaration - row index register  ###
    -- the row index register will hold the value of the row index
    -- when the count after last column was zero
    --max_ridx_count = int(frameSize(1))+1;
    -- ###  3.2 boundary variables for row Padding  ###
    -- ###      3.2.1 head padding variables  ###
    -- start row head padding 
    -- when row index is >= this 
    -- stop row head padding 
    -- when row index > this
    -- matrix indexes that needs to be padded
    sub_cast_2 := signed(resize(row_index_reg, 17));
    sub_temp_1 := to_signed(16#00002#, 17) - sub_cast_2;
    IF sub_temp_1(16) = '1' THEN 
      front_row_index := X"0000";
    ELSE 
      front_row_index := unsigned(sub_temp_1(15 DOWNTO 0));
    END IF;
    --row_head_pad_from = 1; 
    -- ###      3.2.2 tail padding variables  ###
    sub_cast_3 := signed(resize(frameSize_unsigned(0), 17));
    sub_temp_2 := sub_cast_3 - to_signed(16#00001#, 17);
    IF sub_temp_2(16) = '1' THEN 
      start_row_tail_pad := X"0000";
    ELSE 
      start_row_tail_pad := unsigned(sub_temp_2(15 DOWNTO 0));
    END IF;
    -- start row tail padding
    -- when row index is >= this 
    sub_cast_4 := signed(resize(frameSize_unsigned(0), 17));
    sub_temp_3 := sub_cast_4 - to_signed(16#00001#, 17);
    IF sub_temp_3(16) = '1' THEN 
      stop_row_tail_pad := X"0000";
    ELSE 
      stop_row_tail_pad := unsigned(sub_temp_3(15 DOWNTO 0));
    END IF;
    -- stop row tail padding 
    -- when row index > this
    -- matrix indexes that needs to be padded
    IF frameSize_unsigned(0)(15) /= '0' THEN 
      sub_cast_5 := X"7FFF";
    ELSE 
      sub_cast_5 := signed(frameSize_unsigned(0));
    END IF;
    sub_cast_6 := resize(sub_cast_5, 17);
    sub_cast_7 := signed(resize(row_index_reg, 16));
    sub_temp_4 := sub_cast_6 - resize(sub_cast_7, 17);
    IF (sub_temp_4(16) = '0') AND (sub_temp_4(15) /= '0') THEN 
      add_cast := X"7FFF";
    ELSIF (sub_temp_4(16) = '1') AND (sub_temp_4(15) /= '1') THEN 
      add_cast := X"8000";
    ELSE 
      add_cast := sub_temp_4(15 DOWNTO 0);
    END IF;
    add_cast_0 := resize(add_cast, 17);
    add_temp := add_cast_0 + to_signed(16#00001#, 17);
    IF (add_temp(16) = '0') AND (add_temp(15) /= '0') THEN 
      tail_row_index := X"7FFF";
    ELSIF (add_temp(16) = '1') AND (add_temp(15) /= '1') THEN 
      tail_row_index := X"8000";
    ELSE 
      tail_row_index := add_temp(15 DOWNTO 0);
    END IF;
    --row_tail_pad_until = NH_COLS;
    -- ###  3.3 padding action ###

    FOR i_0 IN 0 TO 2 LOOP
      cast_1(i_0) := signed(resize(front_row_index, 32));
      IF (to_signed(1 + i_0, 32) < cast_1(i_0)) AND (rowIndex_unsigned <= to_unsigned(16#00000001#, 8)) THEN 
        -- replicate padding

        FOR t_5 IN 0 TO 2 LOOP
          add_cast_1(t_5) := signed(resize(front_row_index, 32));
          row_padded_nhood(i_0 + (3 * t_5)) := col_padded_nhood(to_integer((add_cast_1(t_5) + to_signed(3 * t_5, 32)) - 1));
        END LOOP;

      ELSE 
        cast_2(i_0) := signed(resize(row_index_reg, 32));
        cast_3(i_0) := signed(resize(start_row_tail_pad, 32));
        cast_4(i_0) := signed(resize(row_index_reg, 32));
        cast_5(i_0) := signed(resize(stop_row_tail_pad, 32));
        IF ((to_signed(1 + i_0, 32) > resize(tail_row_index, 32)) AND (cast_2(i_0) >= cast_3(i_0))) AND (cast_4(i_0) <= cast_5(i_0)) THEN 
          -- replicate padding

          FOR t_6 IN 0 TO 2 LOOP
            row_padded_nhood(i_0 + (3 * t_6)) := col_padded_nhood(to_integer((resize(tail_row_index, 32) + to_signed(3 * t_6, 32)) - 1));
          END LOOP;

        ELSE 

          FOR t_4 IN 0 TO 2 LOOP
            row_padded_nhood(i_0 + (3 * t_4)) := col_padded_nhood(i_0 + (3 * t_4));
          END LOOP;

        END IF;
      END IF;
    END LOOP;

    -- ----------------- end  row  padding  -------------------------
    -- ----------------------------------------------------------------
    --                    4. assign output  
    -- ----------------------------------------------------------------
    --output must be reshaped to a vector
    y_tmp <= row_padded_nhood;
    -- ----------------- assign output   ----------------------------
    -- ----------------------------------------------------------------
    --                    5. update persistent variables 
    -- ----------------------------------------------------------------
    --  ###  5.1 shift registers (for storing old data_in) ### 
    old_cols_next(0 TO 2) <= old_cols(3 TO 5);
    old_cols_next(3 TO 5) <= columnIn_unsigned(0 TO 2);
    --   ### 5.2 row index register  ### 
    -- the row index register will latches the value of the row index
    -- when the count after last column was zero - this helps 
    -- row padding in case of insufficient or no horizontal blanking
    -- it is particularly important for the bottom edge of the image. 
    IF (count_after_last_col = '0') OR (count_after_last_col = '1') THEN 
      row_index_reg_next <= resize(rowIndex_unsigned, 9);
    END IF;
    -- ##   5.3 count after last column  ### 
    -- it starts after at the next clock after the last column 
    -- has be received with 1. it goes from 1 to max_calc_count and then to 
    -- zero. It stays on zero until next last column arrives. 
    cast_6 := signed(resize(colIndex_unsigned, 32));
    sub_cast_8 := signed(resize(frameSize_unsigned(1), 17));
    sub_temp_5 := sub_cast_8 - to_signed(16#00001#, 17);
    IF sub_temp_5(16) = '1' THEN 
      cast_7 := X"0000";
    ELSE 
      cast_7 := unsigned(sub_temp_5(15 DOWNTO 0));
    END IF;
    cast_8 := signed(resize(cast_7, 32));
    IF (hdlcoder_to_stdlogic(cast_6 = cast_8) AND activePixel) = '1' THEN 
      count_after_last_col_next <= '1';
    ELSIF count_after_last_col = '1' THEN 
      count_after_last_col_next <= '0';
    ELSIF (count_after_last_col < '1') AND (count_after_last_col > '0') THEN 
      add_cast_2 := '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & count_after_last_col;
      add_temp_0 := add_cast_2 + 1;
      cast_9 := unsigned(add_temp_0(7 DOWNTO 0));
      IF cast_9(7 DOWNTO 1) /= "0000000" THEN 
        count_after_last_col_next <= '1';
      ELSE 
        count_after_last_col_next <= cast_9(0);
      END IF;
    END IF;
  END PROCESS Make_Neighborhood_1_output;


  outputgen: FOR k IN 0 TO 8 GENERATE
    y(k) <= std_logic_vector(y_tmp(k));
  END GENERATE;

END rtl;

